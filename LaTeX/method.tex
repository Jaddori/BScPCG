\section{Method}

	\subsection{City generation method}
	Most related work focus on one of two things: procedurally generating unique building meshes(TODO: ref) or procedurally generating large cities consisting of similar looking buildings(TODO: ref). This work focuses instead on the procedurally generated placement of authored meshes in varied districts. The concept of districts breaks up the repetitive and self-similar nature of city by introducing distinct changes in appearance between them. During research three stages of generation were recognized: Districts, Blocks and Buildings. Each of these steps use the result of the previous one as starting point, in a top-down, hierarchical manner. Going through these stages is intended to generate a city that feels and looks natural.

		\subsubsection{Districts}
		The generation process starts with the generation of Districts. A District is an abstract representation of an area of the city. It controls what type of buildings it contains, the minimum and maximum height of these buildings and how densely populated the area is with these buildings. With just these few variables, you can create anything from a sparse industrial district to a dense inner city.(TODO: More stuffs here)
		
		\subsubsection{Blocks}
		The next stage in the process is the generation of Blocks. In this work, a Block is defined as an area enclosed by four roads. Looking at aerial photographs of large cities(TODO: ref) a certain pattern sometimes appears in the way roads are laid out. There is usually a few major roads stretched throughout the city and smaller, perpendicular roads connecting them together. We decided to mimic this style(TODO: Don't use we). Since a block is another abstract representation of an area, it is actually the roads that make them up. The first step of generating blocks is to generate the main roads running through the city. After the main roads have been generated, smaller roads are generated between, connecting them together. After all roads have been generated, the city has affectively been divided into a non-uniform grid. Each cell in this grid is a block. (TODO: This stage does not depend on the previous)
		
		\subsubsection{Buildings}
		The final stage is the generation of Buildings. Each building is made up of three meshes: the bottom, middle and top meshes. By dividing a building into sections, it is possible to assemble different pieces and generate new buildings. This is a powerful way to use combinatorics to generate more content. For example, authoring two buildings would result in two unique buildings. Whereas authoring two bottom, middle and top parts would result in eight unique buildings. Upon generation of a buildings, the attributes of its district is taken into consideration. What sections to combine, the minimum and maximum height as well as the density of buildings, is all dictated by the district.

	\subsection{Implementation}
	To explore the procedural generation of a city, a desktop application was created. The application provides the end user with an interface that allows for the configuration of variables along with some statistics. 
	
		\subsubsection{Interface}
		The core functionality of our application is in the form of a proprietary static library called Elicras. It was decided early on that there should be a separation between the graphical user interface and the functionality of the application. It is therefore possible to move Elicras into another front facing interface without any significant changes to the underlying code. Elicras is divided into three areas: Rendering, Assets and PCG. Rendering, as the name implies, handles all the OpenGL function calls. Assets handles all the loading and using of models and textures. PCG handles all the generation of procedural content. The front facing system interacts with these subsystems through Elicras.
		
		\par
		The graphical interface is implemented using Qt(TODO: ref). Qt is an abstraction layer between its supported platforms and their user interface. Using Qt it is possible to create an application once and deploy it all of its supported platforms, including Windows, OSX and Linux. It abstracts away a lot of low level(TODO: ref win32 programming) platform code and provides an easy to use, WYSIWYG(TODO: ref dictionary) graphical interface where you can create the graphical interface for you application. (TODO: Image of Qt editor).
		
		\par
		The interface is divided into three sections that are laid out horizontally. The left section is for statistics such as number of buildings in each of the districts, number of roads and the time it took to generate the city. The middle section displays the generated city. The right section of the interface contains controls for altering how the city is generated. There are three parameters per district: minimum height, maximum height and density of buildings. There is also a global parameter called the seed. The seed can alter the look of the city without altering the per-district parameters. When the end user is satisfied with the parameters, they press the 'Generate' button and a city is generated and displayed on the screen.(TODO: Image of the user interface)
		
		\subsubsection{Districts}
		Explain how we generate districts
		
		\subsubsection{Blocks}
		After generating districts, the roads are generated (effectively creating blocks). The first step is to generate the main roads running through the city. Main roads always run vertically through the city, no matter what parameters are used. To figure out where the main roads should be, Perlin noise is used. By going through the cells of the map horizontally and checking if the Perlin noise for that cell is above a certain threshold, Elicras determines if that cell should be a main road or not. Since the main roads run through the whole city, the algorithm only goes through the first row of cells. If the algorithm determines that a cell should contain a main road, it sets the value of that cell to indicate that it now contains a main road. (TODO: Image console window after main roads). After generating the main roads, smaller roads are generated. This algorithm works on two levels. The first level calculates the width of the road by starting at its current position in the map and going right until it finds a main road. The next level works much the same way as the algorithm for generating the main roads, but it goes vertically instead of horizontally.(TODO: image) When the second level reaches the bottom of the map, it goes back to the first level. Road generation is complete when the end of the map is reached.(TODO: image)
		
		\subsubsection{Buildings}
		The final stage of the generation process it the generation of buildings. At this point the map contains values that indicate whether a cell is a road or a vacant slot belonging to a district. This stage goes through the whole map, skipping over any roads. For each cell that the algorithm visits, three of the districts parameters are considered: minimum height, maximum height and density. The algorithm retrieves a Perlin noise value for the cell and compares it against the density threshold to determine whether to place a building or leave the cell vacant. If a building is placed, the algorithm uses Perlin noise to choose a bottom, middle and top sections. It chooses these sections from the list of available sections that belong to the district. Since the result of Perlin noise is a value between zero and one, it is easy to multiply this result with the number of available sections in order to choose one. The final step of the algorithm determines the height of the building by multiplying the difference between the maximum height and the minimum height with the result from the Perlin noise and then adding the minimum height. (TODO: Math formula?) The results of the building generation is not stored in the map, but in a separate list of building sections that can later be rendered.(TODO: Images)

	\subsection{Data collection}
	Vilken data / hur mycket / hur samlas den