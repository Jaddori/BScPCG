\section{Method}

	\subsection{City generation method}
	Most related work focus on one of two things: procedurally generating unique building meshes(TODO: ref) or procedurally generating large cities consisting of similar looking buildings(TODO: ref). This work focuses instead on the procedurally generated placement of authored meshes in varied districts. The concept of districts breaks up the repetitive and self-similar nature of city by introducing distinct changes in appearance between them. During research three stages of generation were recognized: Districts, Blocks and Buildings. Each of these steps use the result of the previous one as starting point, in a top-down, hierarchical manner. Going through these stages is intended to generate a city that feels and looks natural.

		\subsubsection{Districts}
		The generation process starts with the generation of Districts. A District is an abstract representation of an area of the city. It controls what type of buildings it contains, the minimum and maximum height of these buildings and how densely populated the area is with these buildings. With just these few variables, you can create anything from a sparse industrial district to a dense inner city. The districts have a semi-random deterministic spread across the city. There is no constraints on the distribution of the districts. This means that one seed may produce a city where 90\% is occupied by one district. There are no constraints to prevent this because this would hinder the variability of the cities generated. The districts typically have a lot of blocks where no other districts are competing. But at the borders between districts there is a lot more variation, this is refered to as \textit{border competition}. Here a single block may contain buildings from all three districts. This was done to avoid hard borders between the districts. The hard borders were concidered to look strange and may compromise the cities viability in games. The districts were deemed important as they provide variation throughout the city. (TODO: More stuffs here)
		
		\subsubsection{Blocks}
		The next stage in the process is the generation of Blocks. In this work, a Block is defined as an area enclosed by four roads. Looking at aerial photographs of large cities(TODO: ref) a certain pattern sometimes appears in the way roads are laid out. There is usually a few major roads stretched throughout the city and smaller, perpendicular roads connecting them together. We decided to mimic this style(TODO: Don't use we). Since a block is another abstract representation of an area, it is actually the roads that make them up. The first step of generating blocks is to generate the main roads running through the city. After the main roads have been generated, smaller roads are generated between, connecting them together. After all roads have been generated, the city has affectively been divided into a non-uniform grid. Each cell in this grid is a block. (TODO: This stage does not depend on the previous)
		
		\subsubsection{Buildings}
		The final stage is the generation of Buildings. Each building is made up of three meshes: the bottom, middle and top meshes. By dividing a building into sections, it is possible to assemble different pieces and generate new buildings. This is a powerful way to use combinatorics to generate more content. For example, authoring two buildings would result in two unique buildings. Whereas authoring two bottom, middle and top parts would result in eight unique buildings. Upon generation of a buildings, the attributes of its district is taken into consideration. What sections to combine, the minimum and maximum height as well as the density of buildings, is all dictated by the district.

	\subsection{Implementation}
	To explore the procedural generation of a city, a desktop application was created. The application provides the end user with an interface that allows for the configuration of variables along with some statistics. 
	
		\subsubsection{Interface}
		The core functionality of our application is in the form of a proprietary static library called Elicras. It was decided early on that there should be a separation between the graphical user interface and the functionality of the application. It is therefore possible to move Elicras into another front facing interface without any significant changes to the underlying code. Elicras is divided into three areas: Rendering, Assets and PCG. Rendering, as the name implies, handles all the OpenGL function calls. Assets handles all the loading and using of models and textures. PCG handles all the generation of procedural content. The front facing system interacts with these subsystems through Elicras.
		
		\par
		The graphical interface is implemented using Qt(TODO: ref). Qt is an abstraction layer between its supported platforms and their user interface. Using Qt it is possible to create an application once and deploy it all of its supported platforms, including Windows, OSX and Linux. It abstracts away a lot of low level(TODO: ref win32 programming) platform code and provides an easy to use, WYSIWYG(TODO: ref dictionary) graphical interface where you can create the graphical interface for you application. (TODO: Image of Qt editor).
		
		\par
		The interface is divided into three sections that are laid out horizontally. The left section is for statistics such as number of buildings in each of the districts, number of roads and the time it took to generate the city. The middle section displays the generated city. The right section of the interface contains controls for altering how the city is generated. There are three parameters per district: minimum height, maximum height and density of buildings. There is also a global parameter called the seed. The seed can alter the look of the city without altering the per-district parameters. When the end user is satisfied with the parameters, they press the 'Generate' button and a city is generated and displayed on the screen.(TODO: Image of the user interface)
		
		\subsubsection{Districts}
		The district PCG generates a 2D grid with cells where each cell contains a district number. Each cell is in the later stages filled with grass, roads or buildings. Each cell within the grid represents an area of land in the city. These areas are square shaped with a length of 10 meters which equates to a total area of 100 square meters for each cell.
		
		\par
		Each district has a starting position; this will be referred to as the districts core. The core position of each district is semi-randomly distributed throughout the city with modified Perlin noise. From the core position each district takes control over all the cells they are closest to. The distance is calculated with Euclidian distance squared. The squared distance is used because this is faster for the computer to calculate than the real distance. The equation where \textbf{A} and \textbf{B} are 2D positions:
		\begin{equation}
			EuclideanSquaredDistance = (B1 - A1)^2 + (B2 - A2)^2
		\end{equation}
		
		\par
		After the districts have expanded from their core position, the borders are clear to see. There are often clear lines where on one side there are skyscrapers and on the other there are industry for example. To negate this effect somewhat \textit{border competition} was implemented. The algorithm finds every cell where two different districts meet (i.e. One district in the cell and another district in the cell to the right). The competition range is 30\% of the total grid size. From the border cells we expand half the competition range to the left and the other half to the right; this is done in the X-axis only. For every cell that is in the competition range the two districts compete with modified Perlin noise. If the Perlin noise is above the value of 0.5 the district to the right wins, otherwise the district to the left wins. The winning district takes ownership of the cell.
		
				\subsection{Modified Perlin noise}
		Depending on the \textit{frequency} and \textit{modifications} of the noise the results can be very different. The steps at which the data is sampled is what the \textit{frequency} is. If the results of the Perlin noise is changed further this is what \textit{modifications} is.
		The modified Perlin noise is used when generating the districts. This noise has much sharper changes in values than regular Perlin noise does. Perlin noise without modification returns a value very close to 0.5 most of the time. This pose a problem when generating certain things. The districts core position for example should have some spread across the city and not be close to each nother. The Perlin noise is modified in the following way when generating a districts X-axis position; and used similarly for other parts of the generation:
		
		\texttt{float noise = 20 * this->noise->generate(1.134 * x, 1.22 * y);
			noise = (noise - floor(noise));}
		
		The \textit{frequency} of this modified noise is 1.134 on the X-axis and the \textit{modification} is \texttt{noise = (noise - floor(noise))}.
		The difference between modified and not modified Perlin noise is visualized in \textit{Figure \ref{fig:normal-and-modified-perlin}}.
		
		\begin{figure}[h]
			\begin{subfigure}{0.5\textwidth}
				\centering
				\includegraphics[width=0.9\linewidth]{"Images/floor perlin"}
				\caption[Floored Perlin noise]{Modified Perlin noise}
				\label{fig:modified-perlin}
			\end{subfigure}
			\begin{subfigure}{0.5\textwidth}
				\centering
				\includegraphics[width=0.9\linewidth]{"Images/normal perlin"}
				\caption[Normal Perlin noise]{Normal Perlin noise}
				\label{fig:normal-perlin}
			\end{subfigure}
			\caption{Different uses of Perlin noise}
			\label{fig:normal-and-modified-perlin}
		\end{figure}
		    
		
		\subsubsection{Blocks}
		After generating districts, the roads are generated (effectively creating blocks). The first step is to generate the main roads running through the city. Main roads always run vertically through the city, no matter what parameters are used. To figure out where the main roads should be, Perlin noise is used. By going through the cells of the map horizontally and checking if the Perlin noise for that cell is above a certain threshold, Elicras determines if that cell should be a main road or not. Since the main roads run through the whole city, the algorithm only goes through the first row of cells. If the algorithm determines that a cell should contain a main road, it sets the value of that cell to indicate that it now contains a main road. (TODO: Image console window after main roads). After generating the main roads, smaller roads are generated. This algorithm works on two levels. The first level calculates the width of the road by starting at its current position in the map and going right until it finds a main road. The next level works much the same way as the algorithm for generating the main roads, but it goes vertically instead of horizontally.(TODO: image) When the second level reaches the bottom of the map, it goes back to the first level. Road generation is complete when the end of the map is reached.(TODO: image)
		
		\subsubsection{Buildings}
		The final stage of the generation process it the generation of buildings. At this point the map contains values that indicate whether a cell is a road or a vacant slot belonging to a district. This stage goes through the whole map, skipping over any roads. For each cell that the algorithm visits, three of the districts parameters are considered: minimum height, maximum height and density. The algorithm retrieves a Perlin noise value for the cell and compares it against the density threshold to determine whether to place a building or leave the cell vacant. If a building is placed, the algorithm uses Perlin noise to choose a bottom, middle and top sections. It chooses these sections from the list of available sections that belong to the district. Since the result of Perlin noise is a value between zero and one, it is easy to multiply this result with the number of available sections in order to choose one. The final step of the algorithm determines the height of the building by multiplying the difference between the maximum height and the minimum height with the result from the Perlin noise and then adding the minimum height. (TODO: Math formula?) The results of the building generation is not stored in the map, but in a separate list of building sections that can later be rendered.(TODO: Images)

	\subsection{Data collection}
	Aside from the core functionality of the application, an effort was made to record any significant data about the generation process. The observer pattern was used at the core of this effort. In Elicras there is a DataManager and many DataHolders. Any class whose data is worth collecting, inherits from the DataHolder base class. This results in a centralized way of collecting data that is easy to use and to setup. When Elicras requests the data from the DataManager, it notifies the registered DataHolders to supply their data. The application gathers the following information about the generation process:
		\begin{itemize}
			\item Number of Perlin noise calls
			\item Number of main roads
			\item Number of small roads
			\item Number of buildings in district 1-3
			\item Total number of buildings
			\item Number of grass tiles in district 1-3
			\item Total number of grass tiles
			\item Generation time
		\end{itemize}